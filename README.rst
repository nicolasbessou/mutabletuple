=============
mutabletuple
=============

Overview
========

mutabletuple provides a factory function, mutabletuple.mutabletuple
which is similar to namedlist.namedlist with the following differences:

* Print like a native python dictionary
* Improve support for nested mutabletuple
* Conversion to dictionary is done recursively
* Can iterate using iteritems like dictionary
* Merge nested mutable tuple from dict or other mutabletuple
* MtFactory support arguments
* Nested pickle support

!! Warning !! Pickling does not work for mutabletuple that have no default values.


Typical usage
=============

You can use mutabletuple like a mutable namedtuple::

    >>> from mutabletuple import mutabletuple

    >>> Point = mutable('Point', 'x y')
    >>> p = Point(1, 3)
    >>> p.x = 2
    >>> assert p.x == 2
    >>> assert p.y == 3

Or, you can specify a default value for all fields::

    >>> Point = mutabletuple('Point', 'x y', default=3)
    >>> p = Point(y=2)
    >>> assert p.x == 3
    >>> assert p.y == 2

Or, you can specify per-field default values::

    >>> Point = mutabletuple('Point', [('x', 0), ('y', 100)])
    >>> p = Point()
    >>> assert p.x == 0
    >>> assert p.y == 100

You can also specify the per-field defaults with a mapping, instead
of an iterable. Note that this is only useful with an ordered
mapping, such as an OrderedDict::

    >>> from collections import OrderedDict
    >>> Point = mutabletuple('Point', OrderedDict((('y', 0),
    ...                                         ('x', 100))))
    >>> p = Point()
    >>> p
    Point(y=0, x=100)

The default value will only be used if it is provided and a per-field
default is not used::

    >>> Point = mutabletuple('Point', ['x', ('y', 100)], default=10)
    >>> p = Point()
    >>> assert p.x == 10
    >>> assert p.y == 100

If you use a mapping, the value MtNoDefault is convenient to specify
that a field uses the default value::

    >>> from mutabletuple import MtNoDefault
    >>> Point = mutabletuple('Point', OrderedDict((('y', MtNoDefault),
    ...                                         ('x', 100))),
    ...                            default=5)
    >>> p = Point()
    >>> assert p.x == 100
    >>> assert p.y == 5

All of the documentation below in the Specifying Fields and Specifying
Defaults sections applies to mutabletuple.mutabletuple.

Creating types
==============

Specifying Fields
-----------------

Fields in mutabletuple.mutabletuple can be specified
as in collections.namedtuple: as either a string specifing the field
names, or as a iterable of field names. These two uses are
equivalent::

    >>> Point = mutabletuple('Point', 'x y')
    >>> Point = mutabletuple('Point', ['x', 'y'])

If using a string, commas are first converted to spaces. So these are
equivalent::

    >>> Point = mutabletuple('Point', 'x y')
    >>> Point = mutabletuple('Point', 'x,y')


Writing to values
-----------------

Instances of the classes generated by namedlist.namedlist are fully
writable, unlike the tuple-derived classes returned by
collections.namedtuple or namedlist.namedtuple::

    >>> Point = namedlist('Point', 'x y')
    >>> p = Point(1, 2)
    >>> p.y = 4
    >>> assert p.x == 1
    >>> assert p.y == 4


Additional class members
------------------------

mutabletuple.mutabletuple class contain these members:

* _asdict(): Returns a dict which maps field names to their
  corresponding values.

* _fields: Tuple of strings listing the field names. Useful for introspection.

* merge: Recursively merge with a dict or another mutabletuple.

* iteritems: To iterate like a dict.


Mutable default values
----------------------

For mutabletuple.mutabletuple, be aware of specifying mutable default
values. Due to the way Python handles default values, each instance of
a mutabletuple will share the default. This is especially problematic
with default values that are lists. For example::

    >>> A = mutabletuple('A', [('x', [])])
    >>> a = A()
    >>> a.x.append(4)
    >>> b = A()
    >>> assert b.x == [4]

This is probably not the desired behavior, so see the next section.


Specifying a factory function for default values
------------------------------------------------

For mutabletuple.mutabletuple, you can supply a zero-argument callable for a
default, by wrapping it in a MtFactory call. The only change in this
example is to change the default from `[]` to `MtFactory(list)`. But
note that `b.x` is a new list object, not shared with `a.x`::

    >>> from mutabletuple.mutabletuple import MtFactory
    >>> A = mutabletuple.mutabletuple('A', [('x', MtFactory(list))])
    >>> a = A()
    >>> a.x.append(4)
    >>> b = A()
    >>> assert b.x == []

Every time a new instance is created, your callable (in this case,
`list`), will be called to produce a new instance for the default
value.

Iterating over instances
------------------------

Because instances are iterable (like lists or tuples), iteration works
the same way. Values are returned in definition order::

    >>> Point = mutabletuple.mutabletuple('Point', 'x y z t')
    >>> p = Point(1.0, 42.0, 3.14, 2.71828)
    >>> for value in p:
    ...    print(value)
    1.0
    42.0
    3.14
    2.71828

Creating and using instances
============================

Because the type returned by mutabletuple.mutabletuple is a normal
Python class, you create instances as you would with any Python class.

